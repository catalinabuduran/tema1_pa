Problema 1 - Servere
In implementarea acestei probleme m am ajutat de functiile:
-binarySearch - pentru a găsi valoarea curentului care maximizează puterea minimă calculată în pasul anterior(unde minim_power_of_mid reprezinta puterea minima calculata la curentul mid, adica intre limita inferioara si superioara, iar right_min_power_of_mid este puterea minima calculata la curentul mid+acea precizie de care ni se spune in enunt- acest parametru este esențial pentru a înțelege dacă puterea sistemului crește sau scade atunci când curentul este foarte putin mărit)
-minim_power - care calculează puterea minimă a sistemului pentru o anumită cantitate de curent (se face prin calcularea puterii pentru fiecare server la alimentarea respectiva și apoi prin identificarea puterii minime printre toate serverele)
In rezolvare am cautat cu "cautare binara" valoarea optima a curentului in intervalul determinat de valorile minime și maxime ale cantitatii de curent ale tuturor serverelor(daca as pune limita inferioara a intervalului o valoare mai mica decat cantitatea minima de curent, atunci cel puțin un server functioneaza sub capacitatea optimă, iar puterea de calcul a acelui server va fi redusă, iar daca setez limita superioara ca fiind o valoare mai mare decat cantitatea maxima de curent, atunci cel putin un server o sa fie supraalimentat). In functia de cautare binara, scopul comparației între minim_power_of_mid și right_min_power_of_mid este de a determina dacă creșterea curentului duce la o îmbunătățire sau nu a puterii minime a sistemului. Complexitatea totala este O(logn).

Problema 2 - Colorare
In implementarea acestei probleme m am ajutat de functia fastPow, care reprezinta ridicarea la putere a unui numar, insa este o varianta optimizata cu complexitatea log n.
Apoi citind din datele de intrare fiecare pereche de tipul (int, char), am studiat fiecare caz tinand cont de dispunerea zonelor(verticale/orizontale). Pentru a-mi da seama de fiecare formula valabila pentru fiecare caz citit de la tastatura am luat cateva exemple pe foaie din input, am desenat dreptunghiurile si am calculat. In implementare a fost nevoie sa retin tipul anterior de dispunere a zonei, ca sa stiu in cate moduri mai puteam sa colorez dreptunghiurile, tinand cont si de faptul ca zonele dispuse orizontal erau reprezentate de 2 dreptunghiuri. Complexitatea O(KlogK).

Problema 3 - Compresie
In implementarea acestei probleme m am ajutat de functia bubbleSort pentru a sorta cei 2 vectori crescator pentru a avea o implementare optimizata astfel incat atunci cand parcurg vectorii de sume sa nu fie nevoie sa i parcurg de mai multe ori pentru fiecare element, cautand pe net am aflat ca in java era si o functie predefinita pentru asa ceva, insa apucasem sa fac implementarea; m am ajutat si de o functie care construieste pentru un vector dat, vectorul sau de sume partiale, adica pentru fiecare pozitie aflu suma pana la acea pozitie + valoarea curenta. Dupa ce fac vectorul de sume partiale reprezentativ pentru fiecare sir, parcurg noii vectori de sume si intr-o noua variabila numar elementele comune dintre ei, care reprezinta lungimea maxima a sirului obtinut prin insumarea anumitor elemente ale vectorului(asta daca se poate obtine un astfel de sir, daca nu se poate, se afiseaza -1).Complexitatea O(n^2)

Problema 4 - Criptare
Am pornit cu implementarea de la algoritmul "rucsac" prezentat la laborator, doar ca fiecarei litere distincte ii apartine un rucsac, iar greutatii rucsacului din algoritmul prezentat e lungimea totala a cuvintelor concatenate, iar valoarea produselor este frecventa fiecarei litere din fiecare cuvant. Am folosit: un set pentru a retine fiecare litera distincta din toate cuvintele, un vector in care calculez lungimea subsecventei care contine litera respectiva, in count calculez frecventa fiecarei litere din cuvantul curent. In interiorul for-ului, pentru fiecare pozitie j, se actualizeaza valoarea din vectorul dp[j] astfel incat sa retina numarul maxim de aparitii ale literei curente în subsecventa de lungime j. Acest lucru se face prin adaugarea la dp[j] a numarului de aparitii al literei curente din cuvantul curent in cazul în care lungimea subsecventei j permite includerea intregului cuvant in subsecventa, apoi verific daca e indeplinita conditia cu litera dominanta, in caz afirmativ, actualizez lungimea maxima.Complexitate: O(N*L), N=nr cuvintelor, L=lungimea totala a cuv

Problema 5 - Oferta
In implementarea problemei am avut in vedere sa aflu costul minim pentru a cumpăra produsele de pe bandă, ținând cont de posibilitatea de a grupa produse adiacente conform ofertelor date. Am initializat vectorul cost, care va stoca costul minim pentru a cumpăra primele i produse cu o valoare mare (Double.MAX_VALUE), pentru a asigura ca, pe parcursul calculelor ulterioare, valorile minime vor fi actualizate corect.
Parcurgand toate produsele de pe banda, aflu costul minim astfel:
-dacă cumpar un produs individual (i), costul este minimul dintre costul anterior si pretul produsului curent
-dacă grupez doua produse adiacente (i și i+1), costul este minimul dintre costul anterior si suma preturilor celor două produse minus 50% din pretul mai mic dintre cele doua
-dacă grupez trei produse adiacente (i, i+1 și i+2), costul este minimul dintre costul anterior si suma preturilor celor trei produse minus cel mai mic pret dintre cele trei. Complexitatea O(N).